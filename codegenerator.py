#!/usr/bin/env python

# REGISTERS
ZERO = 0 # always zero
AC1  = 1 # Accumulator 1
AC2  = 2 # Accumulator 2
AC3  = 3 # Accumulator 3
ST   = 4 # Temporary storage
FP   = 5 # points to the start of the frame
SP   = 6 # points to the top of the stack
PC   = 7 # points to the next instruction

# Code generation utilities -------------------------------------------------

def push_register(reg):
    """Creates code for pushing a register onto the stack."""
    return [('LDA', SP, -1, SP, 'Push the stack pointer'),
            ('ST', reg, 0, SP, 'Store reg %s on the stack' % reg)]

def pop_register(reg):
    """Creates code for popping a register off the stack."""
    return [('LD', reg, 0, SP, 'Pop reg %d off the stack' % reg),
            ('LDA', SP, 1, SP, 'Pop the stack pointer')]

def comment(comment):
    """Makes a comment line."""
    return [('comment', 0, 0, 0, comment)]

def passthru(ast):
    """
    Code generated by this item is the sequential concatenation of its
    children. Useful for statements, etc.
    """
    from operator import add
    return reduce(add, [generate_code(c) for c in ast.children], [])

# NODE_TYPE RULES ---------------------------------------------------------

def literal(ast):
    """Generates code for literal constants."""
    if ast.ice9_type == 'int' or ast.ice9_type == 'bool':
        return [('LDC', AC1, int(ast.value), 0, 'load constant: %s' % ast.value)]
    elif ast.ice9_type == 'str':
        # TODO: implement strings
        pass

def writes(ast):
    """Handles writing to output."""
    value = ast.children[0]
    childcode = generate_code(ast.children[0])
    if value.ice9_type == 'int':
        return childcode + [('OUT', AC1, 0, 0, 'writing int')]
    elif value.ice9_type == 'bool':
        return childcode + [('OUTB', AC1, 0, 0, 'writing bool')]
    else:
        raise ValueError("unimplmented")

def write(ast):
    """Handles write command (contains a newline)."""
    return writes(ast) + [('OUTNL', 0, 0, 0, 'newline for write')]

def program(ast):
    """Generates code for a whole program."""
    code5  = comment("PREAMBLE")
    
    # set the stack pointer
    code5 += [('LD', SP, ZERO, ZERO, 'Set the stack pointer')]
    
    code5 += comment("END PREAMBLE")
    code5 += comment("START OF PROGRAM")
    # general program code.
    code5 += passthru(ast)
    code5 += comment('END OF PROGRAM')
    return code5

# Binary operators ---------------------------------------------------------
def binary_operator(opinst, ast):
    """
    Generic binary operator handler. opinst should one of ADD, SUB, DIV or 
    MUL. ast is the AST including the operator node.
    """
    left, right = ast.children
    
    # Store the result of the left operand on the stack.
    code5  = generate_code(left)
    code5 += push_register(AC1)
    
    # store value of right operand is in AC1
    code5 += generate_code(right)
    
    # Get the left value off the stack and put it in AC2
    code5 += pop_register(AC2)
    
    # And add the two and store in AC1
    code5 += [(opinst, AC1, AC2, AC1, '%s left and right.' % opinst)]
    return code5

def add(ast):
    """Handles integer addition and boolean OR."""
    if ast.ice9_type == 'int':
        # integer addition
        return binary_operator('ADD', ast)
    else:
        assert ast.ice9_type == 'bool'
        # boolean OR
        left, right = ast.children
        leftcode = generate_code(left)
        rightcode = generate_code(right)
        
        code5  = comment('boolean OR')
        code5 += leftcode
        code5 += [('JNE', AC1, len(rightcode), PC, 'short circuit boolean OR')]
        code5 += rightcode
        code5 += comment('end boolean OR')
        return code5

def mul(ast):
    """Handles multiplication."""
    return binary_operator('MUL', ast)

def div(ast):
    """Handles division."""
    return binary_operator('DIV', ast)

def sub(ast):
    """Handles both binary and unary subtraction."""
    if len(ast.children) == 1:
        # unary subtract, we really should just multiply by -1
        return generate_code(ast.children[0]) + [
                    ('LDC', AC2, -1, ZERO, 'Prepare to invert sign'),
                    ('MUL', AC1, AC1, AC2, 'Invert sign.')
                ]
    else:
        assert len(ast.children) == 2, "Subtract should only have two nodes"
        return binary_operator('SUB', ast)

# end binary operators ------------------------------------------------------

# condition code ----------------------------------------------------------
def cond(ast):
    children = ast.children
    
    code5 = []
    
    while len(children) > 1:
        cond = children.pop(0)
        dothen = children.pop(0)
        
        stmtcode = generate_code(dothen)
        condcode = generate_code(cond)
        
        code5 += comment('IF condition:')
        code5 += condcode
        code5 += [('JEQ', AC1, len(stmtcode) + 1, PC, 'if false, jump to next cond')]
        code5 += comment('IF was true, THEN:')
        code5 += stmtcode
        code5 += ['jumpend']
        
    if len(children) == 1:
        stmtcode = generate_code(children.pop(0))
        code5 += comment("ELSE:") + stmtcode
    
    # total number of instructions with comments excluded
    codecount = len([1 for inst5 in code5
                     if type(inst5) is not tuple or inst5[0] != 'comment'])
    
    # need to go back and replace our jump labels with the real instruction offsets
    realcode5 = []
    i = 0
    for inst5 in code5:
        if inst5 == 'jumpend':
            # label telling us to jump to the end of the statement
            numleft = codecount - i - 1
            realcode5.append(('JEQ', ZERO, numleft, PC, 'jump to end of if-then-else'))
        else:
            realcode5.append(inst5)
        
        if type(inst5) is not tuple or inst5[0] != 'comment':
            i += 1

    code5 = realcode5
    
    return code5

def do_loop(ast):
    cond, stmt = ast.children
    condcode = generate_code(cond)
    stmtcode = generate_code(stmt)
    
    code5  = comment('BEGIN DO COND')
    code5 += condcode
    code5 += [('JEQ', AC1, len(stmtcode) + 1, PC, 'jump if do cond is false')]
    code5 += comment('cond true, DO:')
    code5 += stmtcode
    code5 += [('JEQ', ZERO, -len(condcode + stmtcode) - 2, PC, 'End of DO, go back to beginning')]
    
    return code5
    

# core algorithm ---------------------------------------------------------

# the repeated callback paradigm
callbacks = {
    'literal': literal,
    'write': write,
    'writes': writes,
    'program': program,
    'statements': passthru,
    '+': add,
    '*': mul,
    '/': div,
    '-': sub,
    'cond': cond,
    'do_loop': do_loop,
}

def generate_code(ast):
    """
    Generates a list of 5-tuples describing instructions for TM code of the form
        (inst, r, s, t, comment)
    """
    def noop(ast):
        # returns empty code
        return []
    
    code5 = []
    if ast.node_type == 'operator':
        cb = callbacks.get(ast.value, noop)
    else:
        cb = callbacks.get(ast.node_type, noop)
    
    # code 5 because callbacks return 5-tuples.
    setattr(ast, 'code5', cb(ast)) 
    return ast.code5

# STRING OUTPUT ------------------------------------------------------------

def code5str(code5):
    """Converts from code5 to something actually usuable by TM."""
    from itertools import count
    output = []
    linecounter = count()
    for inst5 in code5:
        inst, r, s, t, com = inst5
        if inst in ('LDC', 'LDA', 'LD', 'ST', 'JLT', 'JLE', 'JEQ', 
                    'JNE', 'JGE', 'JGT'):
            ln = linecounter.next() # line number
            output.append("%5d: %-9s %d,%d(%d)\t\t%s" % (ln, inst, r, s, t, com))
        elif inst in ('HALT', 'IN', 'OUT', 'INB', 'OUTB', 'OUTC', 
                      'ADD', 'SUB', 'MUL', 'DIV', 'OUTNL'):
            ln = linecounter.next()
            output.append("%5d: %-9s %d,%d,%d\t\t%s" % (ln, inst, r, s, t, com))
        elif inst == 'comment':
            output.append("* %s" % com)
        else:
            raise ValueError("Can't print this instruction: %s" % inst)

    return "\n".join(output)

def generate_code_str(ast):
    """Shorthand for creating the TM string code for the ast."""
    return code5str(generate_code(ast))

# ---------------------------------------------------------------------------

if __name__ == '__main__':
    from ice9 import compile
    source = file('test.9').read()
    print compile(source)
